title: Request handling
--

Plugins can implement request handlers to respond to requests for URLs. This allows them to implement their own user interface seamlessly within the main ONEIS application.

The templating system allows plugins to use the same layout (header, footer, navigation, etc) as the main application, but plugins can respond with any data and header they require.

The request handler API aims to be close to HTTP without any unhelpful abstractions, but avoid the need to write lots of boring boilerplate code. For example, most argument decoding, data lookup and error checking can be done by the framework with simple declarations of requirements.


h2. Declare URL roots

Declare the URL roots in [node:dev/plugin/plugin-json] with the @respond@ key.

Choose URLs which look good and aren't too long. Try to pick names which aren't too generic so they're unlikely to clash with other plugins.

You can only use URLs starting with @/do@ and @/api@. The root level namespace is used for objects, with the first path element being the section name. @/do@ is used for user visible UI, and @/api@ for automated systems.

Note that if you are intending to write an HTTP API which is accessed by external software, it needs to be under @/api@ since API keys are only allowed to access URLs under this root.


h2. Create links in main UI

Use [node:dev/plugin/hook:hooks] to add user interface to the main application which links to your URLs. The most useful hook for this purpose is [node:dev/plugin/hook/object-display].

In addition, [node:dev/plugin/elements:Elements] can be used to add user interface to the application home page and add extra information to object pages, and the [node:dev/plugin/work-flow:work flow system] can be used to add entries to the Task list and on object pages.


h2. Handle requests

In one of your JavaScript files included in the @load@ key in [node:dev/plugin/plugin-json], define the request handlers using the [node:dev/plugin/interface/plugin/request-handling#respond] function in your [node:dev/plugin/interface/plugin] object. A very simple handler might look like this:

<pre>language=javascript
P.respond("GET", "/do/example/object", [
    {pathElement:0, as:"object"}
], function(E, displayedObject) {
    E.render({display: displayedObject});
});
</pre>

Line 1 declares that the plugin will respond to @GET@ requests for any URL at @/do/example/object@ or any 'sub-directory'.

Line 2 defines the argument for the handler function. In this case, the first path element after the given path is expected to be an object reference. This will be loaded and passed as the @displayedObject@ argument. If the object doesn't exist or the user is not permitted to read it, the handler function will never be called.

Line 3 declares the handler function. The first argument, @E@, is the [node:dev/plugin/interface/exchange] object which represents the HTTP request / response exchange. The other arguments have been declared previously. This handler will respond to @/do/example/object/123y5@.

Line 4 is the actual handler. The arguments are guaranteed to have passed validation, so don't need to be checked, and hopefully you won't need to do much processing of parameters yourself.

The handler simply renders a [node:dev/plugin/interface/template]. In this case it's loaded from the @template/object.html@ file, as if you don't explicitly give a template name, the last path element of the URL in the definition is used. The correct MIME type is set for you -- if the @template/object.*@ file had a different extension, such as @css@, the appropriate MIME type would be sent.

For more information on how to declare arguments to your function, see the documentation for [node:dev/plugin/interface/plugin/request-handling#respond].


h2. Callbacks

Three callbacks are provided to modify the request handling process, [node:dev/plugin/interface/plugin/request-callbacks#requestBeforeHandle], [node:dev/plugin/interface/plugin/request-callbacks#requestBeforeRender] and [node:dev/plugin/interface/plugin/request-callbacks#requestAfterHandle].

These allow common functionality in all handlers to implemented without having to copy code into each handler, which is easy to forget. This is useful for things such as authorisation checks and common visual elements for views.


h2. Layouts

For HTML responses, you can use a 'layout' to provide a common header and footer for the page, enabling common navigation and visual styling.

Two standard layouts are provided, @"std:standard"@ and @"std:minimal"@, and the plugin can provide its own layouts as a normal templates.

If no layout is specified in the view, the @"std:standard"@ layout is used. This includes the standard ONEIS user interface, as well as client side resource handling through templates like [node:dev/plugin/templates/std-template/plugin-static].

If one of the plugin's templates is used as a layout:

 * The template will be rendered using the @view@, as normal.
 * The HTML generated by this rendering will be added to the view as the @content@ property.
 * The layout template will be rendered using the @view@.

This process means you can use the view to pass information to the layout as well as the template itself. The layout should include @{{{content}}}@ to output the HTML generated by the template.

You can specify @false@ for no layout. See the view's [node:dev/plugin/interface/exchange#layout] property for details.


h2. CSRF protection

The platform implements automatic "CSRF":https://secure.wikimedia.org/wikipedia/en/wiki/CSRF protection for all POSTed requests.

Unless the request is authenticated by an API key, it must include a @__@ (double underscore) parameter which is set to a per-session secret token. To include this token in your @<form>@s, use the [node:dev/plugin/templates/std-template/form-csrf-token] template as a partial, which generates a suitable hidden @input@ field.
